{"version":3,"file":"content-script.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA","sources":["webpack://bionic-reader-extension/webpack/bootstrap","webpack://bionic-reader-extension/webpack/runtime/define property getters","webpack://bionic-reader-extension/webpack/runtime/hasOwnProperty shorthand","webpack://bionic-reader-extension/webpack/runtime/make namespace object","webpack://bionic-reader-extension/./src/content-script.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let CS_LOG_PREFIX = \"[BRE: c-s via background]\";\nlet isActive = false;\nlet isInit = false;\n\nlet STATUS = {\n    active: false,\n    init: false\n};\n\nexport const DELIMITERS = {\n    HYPHEN: \"-\",\n    DBL_HYPHEN_A: \"--\",\n    DBL_HYPHEN_B: \"â€”\",\n    SPACE: \" \"\n};\n\nlet originalParagraphValues: Array<string> = [];\nlet bionicParagraphValues: Array<string> = [];\n\nlet wordIndex: number = 0, paragraphIndex: number = 0;\n\nenum ITypesCS {\n    log,\n    action,\n    notify\n};\n\n/**\n *\n * Send Message\n *\n * @description helper function to communicate with background.js primarily. Send a message to another part of the extension\n * @param message [string] the message to log (if any)\n * @param type [ITypesCS] the type of event we're sending\n */\nfunction sendMessage(message: string, type?: ITypesCS) {\n    !type ? type = ITypesCS.log : console.log('Nothing to see here');\n\n    chrome.runtime.sendMessage({ message, prefix: CS_LOG_PREFIX, type }, (response) => {\n        if (response) {\n            console.log(response);\n        }\n    });\n}\n\n/**\n *\n * Advanced Parse String\n *\n * @description some \"words\" are actually two words conjoined by hyphens, this auto-detects that and handles parsing correctly\n * @param word [string] a string of continuous characters derived by splitting \" \" on page text\n * @returns [boolean | string] false if not present, string with correctly formatted text if it does\n */\nfunction advancedParseString(word: string): boolean | string {\n    const containsDoubleHyphenA = word.indexOf(DELIMITERS.DBL_HYPHEN_A);\n    const containsDoubleHyphenB = word.indexOf(DELIMITERS.DBL_HYPHEN_B);\n\n    const advancedParseString = word.indexOf(DELIMITERS.HYPHEN);\n\n    if (containsDoubleHyphenA > 0) {\n        sendMessage(`This word contains a standard double hyphen ${word}!`);\n        let words = word.split(DELIMITERS.DBL_HYPHEN_A);\n        return bionicWord(words[0]) + DELIMITERS.DBL_HYPHEN_A + bionicWord(words[1]);\n    } else if (containsDoubleHyphenB > 0) {\n        sendMessage(`This word contains a conjoined double hyphen ${word}!`);\n        let words = word.split(DELIMITERS.DBL_HYPHEN_B);\n        return bionicWord(words[0]) + DELIMITERS.DBL_HYPHEN_B + bionicWord(words[1]);\n    } else if (advancedParseString > 0) {\n        sendMessage(`This word contains one hyphen ${word}!`);\n        let words = word.split(DELIMITERS.HYPHEN);\n        return bionicWord(words[0]) + DELIMITERS.HYPHEN + bionicWord(words[1]);\n    } else if (word.length == 1) {\n        // one-letter words are always bold\n        return `<b>${word}</b>`;\n    } else {\n        return false;\n    }\n}\n\n/**\n *\n * Bionic Word\n *\n * @description create the processed \"bionic\" equivalent of the text, wrapped with <b> tags on the \"bionic\" part\n * which is also enforced with embedded CSS to ensure font-weight is applied over page styling\n * @param word [string] a string of continuous characters derived by splitting \" \" on page text\n * @returns [string] the processed text as HTML\n */\nfunction bionicWord(word: string): string {\n    const mid = Math.floor(word.length / 2);\n    const bionicSlice = word.slice(0, mid);\n    const remainder = word.slice(mid);\n\n    const formattedWordHTML = `<b>${bionicSlice}</b>${remainder}`;\n    return formattedWordHTML;\n}\n\n/**\n *\n * Parse String\n *\n * @description some basic logic to parse strings according to their contents\n * @param str [string] a string of continuous characters derived by splitting \" \" on page text\n * @returns [string] the fully parsed HTML to correctly show the bionic text (inc. special parsing functionality for edge cases)\n */\nfunction parseString(str: string): string {\n    // sendMessage(`Parsing word ${word}`);\n    const advancedParse = advancedParseString(str);\n    if (!advancedParse) {\n        return bionicWord(str);\n    } else {\n        return advancedParse as string;\n    }\n}\n\n/**\n *\n * Parse Bionic\n *\n * @description is able to receive any given HTML element (in reality it should always be a paragraph)\n * and takes the \"textContent\", breaks it up by spaces (\" \") and then parses each word and wraps\n * the \"Bionic\" parts in <b> tags which have additional CSS to enforce the emphasis.\n * @param paragraph [Element || HTMLParagraphElement] any given <p></p> element from a matching page\n *\n */\nfunction parseBionic(paragraph: Element) {\n    let paragraphBionic: string = '';\n\n    if (paragraph['textContent'] != null) {\n        const words: Array<string> = paragraph.textContent.split(\" \");\n\n        words.forEach((word: string) => {\n            let formattedWordHTML = '';\n            formattedWordHTML = parseString(word);\n            paragraphBionic += ' ' + formattedWordHTML;\n            wordIndex++;\n        });\n\n        originalParagraphValues.push(paragraph.textContent as string);\n        bionicParagraphValues.push(paragraphBionic as string);\n\n        paragraph.innerHTML = paragraphBionic;\n        sendMessage(`Completed parsing paragraph ${wordIndex} DOM updated successfully.`);\n    }\n    paragraphIndex++;\n}\n\nfunction toggleBionic() {\n    sendMessage('Toggling bionic...', ITypesCS.notify);\n}\n\n/**\n *\n * Convert Page Text\n *\n * @description accepts an array of HTML elements and iterates over them to run the parser\n * @param paragraphs [NodeListOf<Element | HTMLParagraphElement] a list of elements on a matching page with the <p> tag!\n */\nfunction convertPageText(paragraphs: NodeListOf<Element>) {\n    wordIndex = 0, paragraphIndex = 0;\n\n    paragraphs.forEach((paragraph: Element) => {\n        sendMessage('Handling paragraph...');\n        parseBionic(paragraph);\n    });\n    sendMessage(`Automatically processed ${paragraphIndex} paragraphs and ${wordIndex} words!`, ITypesCS.notify);\n    STATUS.init = true;\n}\n\n/**\n *\n * Auto-grab Paragraphs on a matching page\n *\n * @description: this is a rudimentary function which uses very little intelligence to grab all paragraph text\n * so that it can be parsed/formatted!\n *\n */\nfunction autoGrabParagraphs() {\n    const paragraphs: NodeListOf<Element> = document.querySelectorAll('body p');\n    sendMessage(`There are ${paragraphs.length} paragraphs to parse.`);\n    sendMessage(`Is init? ${STATUS.init}`);\n    if (!STATUS.init) {\n        convertPageText(paragraphs);\n    } else {\n        toggleBionic();\n    }\n}\n\n/**\n *\n * Initialise the content-script\n *\n * @description: embeds into the active page to perform DOM interactions, allowing us to modify article text etc\n *\n */\nfunction initContentScript() {\n    sendMessage(\"Content script initialised!\");\n    autoGrabParagraphs();\n}\n\n// this will only happen on pages matching the content-scripts \"matches\" list of URLs for now\ninitContentScript();"],"names":[],"sourceRoot":""}