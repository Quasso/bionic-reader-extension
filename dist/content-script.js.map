{"version":3,"file":"content-script.js","mappings":";;;;;;;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAGA;AACA","sources":["webpack://bionic-reader-extension/./src/content-script.ts"],"sourcesContent":["let CS_LOG_PREFIX = \"[BRE: contentScript via background]\";\nlet isActive = false;\nlet isInit = false;\n\nlet originalParagraphValues: Array<string> = [];\nlet bionicParagraphValues: Array<string> = [];\n\nlet wordIndex: number, paragraphIndex: number = 0;\n\nenum ITypesCS {\n    log,\n    action\n}\n\n/**\n *\n * Helper function to communicate with background.js primarily\n *\n * @description Send a message to another part of the extension\n * @param message [string] the message to log (if any)\n * @param type [ITypesCS] the type of event we're sending\n */\nfunction sendMessage(message: string, type?: ITypesCS) {\n    !type ? type = ITypesCS.log : console.log('Nothing to see here');\n\n    chrome.runtime.sendMessage({ message, prefix: CS_LOG_PREFIX, type }, (response) => {\n        if (response) {\n            console.log(response);\n        }\n    });\n}\n\nfunction parseBionic(paragraph: Element) {\n    let paragraphBionic: string = '';\n\n    if (paragraph['textContent'] != null) {\n        const words: Array<string> = paragraph.textContent.split(\" \");\n\n        words.forEach((word: string, index: number) => {\n            let formattedWordHTML = '';\n            const mid = Math.floor(word.length / 2);\n            const bioPart = word.slice(0, mid);\n            const remainder = word.slice(mid);\n\n            formattedWordHTML = `<b>${bioPart}</b>${remainder}`;\n            paragraphBionic += ' ' + formattedWordHTML;\n            wordIndex++;\n        });\n\n        originalParagraphValues.push(paragraph.textContent as string);\n        bionicParagraphValues.push(paragraphBionic as string);\n\n        sendMessage('Completed a paragraph...');\n        paragraph.innerHTML = paragraphBionic;\n        sendMessage('DOM updated successfully.');\n    }\n    paragraphIndex++;\n}\n\nfunction toggleBionic() {\n    sendMessage('Toggling bionic...');\n}\n\n/**\n *\n * Convert Page Text\n *\n * @description accepts an array of HTML elements and iterates over them to run the parser\n * @param paragraphs [NodeListOf<Element | HTMLParagraphElement] a list of elements on a matching page with the <p> tag!\n */\nfunction convertPageText(paragraphs: NodeListOf<Element>) {\n    paragraphs.forEach((paragraph: Element) => {\n        sendMessage('Handling paragraph...');\n        parseBionic(paragraph);\n    });\n    isInit = true;\n}\n\n/**\n *\n * Auto-grab Paragraphs on a matching page\n *\n * @description: this is a rudimentary function which uses very little intelligence to grab all paragraph text\n * so that it can be parsed/formatted!\n *\n */\nfunction autoGrabParagraphs() {\n    const paragraphs: NodeListOf<Element> = document.querySelectorAll('body p');\n    sendMessage(`There are ${paragraphs.length} paragraphs to parse.`);\n    sendMessage(`Is init? ${isInit}`);\n    if (!isInit) {\n        convertPageText(paragraphs);\n    } else {\n        toggleBionic();\n    }\n}\n\n/**\n *\n * Initialise the content-script\n *\n * @description: embeds into the active page to perform DOM interactions, allowing us to modify article text etc\n *\n */\nfunction initContentScript() {\n    sendMessage(\"Content script initialised!\");\n    autoGrabParagraphs();\n}\n\n\n// this will only happen on pages matching the content-scripts \"matches\" list of URLs for now\ninitContentScript();"],"names":[],"sourceRoot":""}